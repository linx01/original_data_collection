import jsonimport randomimport reimport timefrom multiprocessing import Lockimport requestsfrom lxml import etreefrom Ocrs import ocrfrom mongodbhelper import mongohelperfrom proxyhelper import insideclass Platforminfo_YiLe(object):    def __init__(self, url='', name='', password='', qq=''):        self._url = url        self._name = name        self._password = password        self._qq = qq        self._header = {            'Connection': 'close',            'X-Requested-With': 'XMLHttpRequest',            'X-XSRF-TOKEN': '',            'X-CSRF-TOKEN': '',            'Cookie': '',  # Cookie + xsrf-token + _session            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36',        }        self._customerservice = ''        self._goodslist = []        self._title = ''        self._notice = ''        self._inside = inside    def get_proxy(self, pid):        proxy = self._inside.get_proxy()        if not proxy.get('data', []):            return None        proxy = {'http': 'http://' + proxy['data'][0]['ip'] + ':' + str(proxy['data'][0]['port'])}        print(' - process - {} - 当前正在使用代理{}'.format(pid, proxy['http']))        return proxy        # proxy = get_proxies()        # try:        #     print(' - process - {} - 当前正在使用代理{}'.format(pid, proxy['http']))        # except KeyError as e:        #     proxy = None    # 过滤登录    def visit(self, url):        try:            response = requests.get(url=url, headers=self._header)            # print(response.text)        except:            return {'code': 504, 'response': '链接无反应'}        if response.status_code == 404:            return {'code': 404, 'response': '页面未找到！'}        # 获取cookies        try:            pattern = re.compile(r".*'cookie'\s:\s\"(\w+)\"\,.*")            result = pattern.findall(response.text)            self._header['Cookie'] += 'Cookie={}'.format(result[0])            response = requests.get(url=url, headers=self._header)            return {'code': 200, 'response': response.text}        except:            return {'code': 503, 'response': '获取cookie失败！'}    def get_parameters(self, url, pid):        # 访问域名主页，获取cookie        time.sleep(3)        proxy = self.get_proxy(pid)        response = requests.get(url=url, headers=self._header, proxies=proxy)        # print(response.text)        pattern = re.compile(r".*\'cookie\'\s\:\s\"(\w+)\".*")        result = pattern.findall(response.text)        try:            self._header['Cookie'] += 'Cookie={}'.format(result[0])        except Exception as e:            return {'code': 404, 'message': 'cookie获取失败！跳过', 'response': response.text}        time.sleep(3)        # 获取csrf-token/xsrf-token/_session        # proxy = self.get_proxy(pid)        # print(self._header)        res = requests.get(url=url, headers=self._header, proxies=proxy)        # print('csrf-token',res.text)        data = res.cookies.get_dict()        # 将xsrf-token与_session放入Cookie中        for key, value in data.items():            self._header['Cookie'] += '; {}={}'.format(key, value)        # 将xsrf-token的值赋值给header中的x-xsrf-token        # print(data)        self._header['X-XSRF-TOKEN'] = data['XSRF-TOKEN']        # 将csrf-token的值赋值给header中的x-csrf-token        pattern1 = re.compile(r".*name=\"csrf\-token\"\scontent=\"(\w+)\".*")        result = pattern1.findall(res.text)        try:            self._header['X-CSRF-TOKEN'] = result[0]        except:            self._header['X-CSRF-TOKEN'] = ''        return {'code': 0, 'message': 'success', 'response': res}    def register(self, pid):        url_captcha = self._url + '/captcha?_=' + str(random.uniform(0, 1))        # 访问域名主页，获取cookie, 返回代理        proxy = self.get_parameters(self._url, pid)        proxy = self.get_proxy(pid)        res_captcha = requests.get(url=url_captcha, headers=self._header, proxies=proxy, timeout=30)        data = ocr.discern(res_captcha.content)        print(' - process - {} - 验证码识别成功!'.format(pid))        code = data['result']        # 构造注册表单        register_form = {            'user': self._name,            'password': self._password,            'qq': self._qq,            'code': code        }        time.sleep(3)        # post注册api        print(' - process - {} - 注册中...'.format(pid))        url_register = self._url + '/reg'        proxy = self.get_proxy(pid)        res_register = requests.post(url=url_register, data=register_form, headers=self._header, proxies=proxy,                                     timeout=30)        data = json.loads(res_register.text)        return data    def get_goodslist(self, pid):        try:            print(' - process - {} - 域名{}获取商品列表中...'.format(pid, self._url))            # 获取客服信息与网站名称            res = self.get_parameters(self._url, pid)            if res['code'] != 0:                return res            res = res['response']            pattern = re.compile(r".*loadKfqq\(\'(.*)\'\).*")            result = pattern.findall(res.text)            try:                self._customerservice = result[0]            except:                self._customerservice = ' '            res_data = etree.HTML(res.text)            try:                self._title = res_data.xpath(r"//h3[@class='titZx']/text()")[0]            except:                self._title = ''            # 获取商品列表            time.sleep(3)            post_goods = {                'action': 'getGoodsAndClass',                'collect': 0,            }            proxy = self.get_proxy(pid)            url_ajax = self._url + '/ajax'            try:                res = requests.post(url=url_ajax, data=post_goods, headers=self._header, proxies=proxy, timeout=30)                res_dict = json.loads(res.text)                info = res_dict['data']['goods']                self._goodslist = info            except Exception as e:                return {'code': 403, 'message': '域名{}获取商品列表失败!原因:{}'.format(self._url, e)}            # 获取公告            time.sleep(3)            post_goods = {                'action': 'notice',                'page': 1,            }            url_ajax = self._url + '/ajax'            proxy = self.get_proxy(pid)            res = requests.post(url=url_ajax, data=post_goods, headers=self._header, proxies=proxy, timeout=30)            res_dict = json.loads(res.text)            try:                info = res_dict['data']['data']                for elem in info:                    self._notice += elem['content']            except:                self._notice = ''            if self._notice == '':                # 如果不是ajax请求，则从主页的公告栏抓取公告                try:                    info = res_data.xpath(r"//div[@class='alert alert-success']//span/text()")                    for elem in info:                        self._notice += elem                except:                    self._notice = ''            if len(self._goodslist) != 0:                return {'code': 0, 'message': '域名{}获取商品列表成功!'.format(self._url)}            else:                return {'code': 404, 'message': '域名{}商品列表为空!无需采集！'.format(self._url)}        except Exception as e:            return {'code': 403, 'message': '域名{}获取商品列表异常!原因:{}'.format(self._url, e)}    def login(self, pid):        # 访问第一个商品链接，得到cookie，再登录        try:            gid = self._goodslist[0]['gid']            url_ = self._url + '/login?go=/home/order/' + str(gid)            time.sleep(3)            proxy = self.get_proxy(pid)            res = requests.get(url=url_, headers=self._header, proxies=proxy, timeout=30)            data = res.cookies.get_dict()            for key, value in data.items():                self._header['Cookie'] += '; {}={}'.format(key, value)            # 登录            url_login = self._url + '/login'            post_login = {                'type': 'user',                'user': self._name,                'password': self._password,            }            time.sleep(3)            proxy = self.get_proxy(pid)            res_login = requests.post(url=url_login, data=post_login, headers=self._header, proxies=proxy, timeout=30)            res_dict = json.loads(res_login.text)            if res_dict.get('errors', '') != '':                return {'code': 403, 'message': '域名{}登录失败，原因:{}'.format(self._url, res_dict['errors']['user'][0])}            else:                # 保存登录cookie                data = res_login.cookies.get_dict()                # 清除之前除了cookie之外的所有值                pattern = re.compile(r".*(Cookie=\w+).*")                result = pattern.findall(self._header['Cookie'])                self._header['Cookie'] = result[0]                # 将登录后获得的cookies保存到Cookie中                for key, value in data.items():                    self._header['Cookie'] += '; {}={}'.format(key, value)                return {'code': 0, 'message': '域名{}登录成功!response:{}'.format(self._url, str(res_dict))}        except Exception as e:            return {'code': 403, 'message': '域名{}登录异常，原因:{}'.format(self._url, e)}    def get_goodsinfo(self, pid):        try:            # 第一次访问，获取gid            proxy = self.get_proxy(pid)            res = requests.get(url=self._url + '/home/order/{}'.format(self._goodslist[0].get('gid')),                               headers=self._header, proxies=proxy, timeout=30)            data = res.cookies.get_dict()            self._header['Cookie'] += '; gid={}'.format(data.get('gid', ''))            time.sleep(5)            i = 0            for elem in self._goodslist:                time.sleep(3)                i += 1                print(' - process - {} - 获取{}第{}条数据...'.format(pid, self._url, i))                goods = {}                goods['No'] = i                goods['platformName'] = self._title                goods['goodsTitle'] = elem.get('name', '')                goodslink = self._url + '/home/order/{}'.format(elem.get('gid'))                # 去重复,对应之前采集到一半发生断网或者进程关闭，无法通过外层去重复，只能逐个商品重新采集去重复                res = mongohelper.search('yilecommunity', 'href', goodslink, pid)                if res:                    print(' - process - {} - 当前商品信息已存在数据库表格中！ - {}'.format(pid, goodslink))                    continue                # 第二次访问，获取单个商品信息，自动重试5次不成功后就跳过不采集，默认采集完毕，遍历完所有商品后url标记完成                proxy = self.get_proxy(pid)                chongshi = 0                res_data = False                while True:                    try:                        res_ = requests.get(url=goodslink, headers=self._header, proxies=proxy, timeout=30)                        res_data = etree.HTML(res_.text)                        break                    except BaseException as e:                        if chongshi < 5:                            print(' - process - {} - 获取{}第{}条数据失败,第{}次尝试...'.format(pid, self._url, i, chongshi + 1))                            chongshi += 1                            time.sleep(30)                            continue                        break                if not res_data:                    print(' - process - {} - 获取{}第{}条数据失败,跳过采集...'.format(pid, self._url, i))                    continue                try:                    goodsprice = res_data.xpath(r"//div[@class='list-group-item list-group-item-success']/text()")[                                     0].strip()[3:]                    if '=' in goodsprice:                        pattern = re.compile(r"([\d\.]+)[\S]+\=([\d]+)[\S]+")                        result = pattern.match(goodsprice)                        money = float(result.group(1))                        amount = float(result.group(2))                        if '万' in goodsprice:                            amount = amount * 10000                        goods['goodsPrice'] = money / amount                    else:                        goods['goodsPrice'] = goodsprice                except:                    goods['goodsPrice'] = ''                try:                    pattern = re.compile(r"(\d+)[\W](\d+)")                    result = pattern.findall(res_data.xpath(r"//input[@name='num']/@placeholder")[0][7:-1])                    goods['goods_min'] = result[0][0]                    goods['goods_max'] = result[0][1]                except:                    goods['goods_min'], goods['goods_max'] = '', ''                goods['goods_id'] = elem.get('gid', '')                goods['goods_type'] = elem.get('cid', '')                goods['href'] = goodslink                goods['customerservice'] = self._customerservice.replace('\"', '\'').replace('>', '').replace('<',                                                                                                              '').replace(                    ';', '').replace('\\', '').replace('\/', '')                goods['notice'] = self._notice.replace('\"', '\'').replace('>', '').replace('<', '').replace(';',                                                                                                             '').replace(                    '\\', '').replace('\/', '')                goods['username'] = self._name                goods['password'] = self._password                goods['platform_url'] = self._url                # 进程互斥锁                mutex = Lock()                print(' - process - {} - 上锁！'.format(pid))                print(' - process - {} - 正在写入信息 '.format(pid), goods)                mutex.acquire()                mongohelper.add('yilecommunity', goods, pid)                mutex.release()                print(' - process - {} - 解锁！'.format(pid))                print(' - process - {} - 写入完成！ '.format(pid), goods)            return {'code': 0, 'message': '域名{}获取商品信息已完成!'.format(self._url)}        except Exception as e:            return {'code': 403, 'message': '域名{}获取商品信息错误!原因:{}'.format(self._url, e)}class Handle_YiLe():    # 注册    @classmethod    def register(cls, index, last, l, pid, length, urls):        print(' - process - {} - start'.format(pid))        url_ = []        url_over = []        for url in urls[index:last]:            if url not in url_:                try:                    i = ''.join(str(random.choice(range(1, 10))) for x in range(5))                    j = ''.join(str(random.choice(range(1, 10))) for x in range(9))                    platforminfo = Platforminfo_YiLe(url, 'linx{}'.format(i), '987654322', '{}'.format(j))                    info = platforminfo.register(pid)                    if str(info['status']) != '0':                        print('- process - {} - {}注册失败,原因 {}'.format(pid, url, info['message']))                        if '站点已' in info['message'] or '该域名' in info['message']:                            print('- process - {} - 不支持访问的网站'.format(pid))                            url_over.append(url)                        continue                    else:                        url_dict = {}                        url_dict['name'] = url                        url_dict['user'] = 'linx{}'.format(i)                        url_dict['password'] = '987654322'                        l.append(url_dict)                        print('- process - {} - {}注册成功 进度：{}/{}'.format(pid, url, len(l), length), l)                        continue                except BaseException as e:                    print('- process - {} - {}注册失败,跳至下一个 {}'.format(pid, url, e))                    continue        print(' - process - {} - over - 失效的网站:'.format(pid), url_over)        print(' - process - {} - over - 已注册的账号信息:'.format(pid), l)        print(' - process - {} - over'.format(pid))    # 采集    @classmethod    def collection(cls, index, last, l, pid, length, urls):        print(' - process - {} - start'.format(pid))        while True:            for url in urls[index:last]:                # 对于已经添加到列表中的url，说明已经采集完整个网站的所有的商品，跳过                if url['name'] in l:                    print('- process - {} - {}已采集，跳过 进度：{}/{}'.format(pid, url['name'], len(l), length), l)                    import time                    time.sleep(10)                    continue                print(' - process - {} - start - {}'.format(pid, url))                platforminfo = Platforminfo_YiLe(url['name'], url['user'], url['password'], '123456789')                res = platforminfo.get_goodslist(pid)                print('- process - {} - {}'.format(pid, url['name']), res['message'])                if res['code'] != 0:                    print('- process - {} - {}采集失败 进度：{}/{}'.format(pid, url['name'], len(l), length), l)                    continue                res = platforminfo.login(pid)                print('- process - {} - {}'.format(pid, url['name']), res['message'])                if res['code'] != 0:                    print('- process - {} - {}采集失败 进度：{}/{}'.format(pid, url['name'], len(l), length), l)                    continue                res = platforminfo.get_goodsinfo(pid)                print('- process - {} - {}'.format(pid, url['name']), res['message'])                if res['code'] != 0:                    print('- process - {} - {}采集失败 进度：{}/{}'.format(pid, url['name'], len(l), length), l)                    continue                l.append(url['name'])                print('- process - {} - {}采集成功 进度：{}/{}'.format(pid, url['name'], len(l), length), l)            # 满足条件，则说明全部采集完毕，跳出循环            if len(l) == length:                print('- process - {} - 全部采集完毕！ 进度：{}/{}'.format(pid, len(l), length), l)                break        print(' - process - {} - over'.format(pid))    # 过滤    @classmethod    def filter(cls, index, last, l, pid, length, urls):        print(' - process - {} - start'.format(pid))        for url in urls[index:last]:            platforminfo = Platforminfo_YiLe(url, 'linx01', '987654322', '410559855')            info = platforminfo.visit(url)            if info['code'] not in [200]:                print('- process - {} - {} status_code:{} 访问失败！原因:{}'.format(pid, url, info['code'], info['response']))                continue            else:                try:                    res = json.loads(info['response'])                    print('- process - {} - {} status_code:{} 访问成功，但{}'.format(pid, url, info['code'], res['message']))                    continue                except:                    if '出错了' in info['response']:                        print('- process - {} - {} status_code:{} 访问成功，但无法使用'.format(pid, url, info['code']))                        continue                    else:                        print('- process - {} - {} status_code:{} 访问成功！{}'.format(pid, url, info['code'],                                                                                  info['response']))                        l.append(platforminfo._url)                        print('- process - {} - {} 过滤成功 进度：{}/{}'.format(pid, url, len(l), length), l)                        continue        print('- process - {} - 可以访问的域名列表为：'.format(pid), l)if __name__ == '__main__':    pass